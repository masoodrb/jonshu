'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * EventManager is a class that is used to emit and subscribe to events.
 *
 * @example
 * You can use it to emit an event:
 * ```typescript
 * const eventManager = new EventManager();
 * eventManager.emit('my_event_name', { foo: 'bar' });
 * ```
 *
 * You can use it to register a callback for an event:
 * ```typescript
 * const eventManager = new EventManager();
 * eventManager.register('my_event_name', (data) => {
 *   console.log(data);
 *   // { foo: 'bar' }
 *   // ...
 * });
 */
class EventManager {
    /**
     * Object that contains all the registered callbacks for each topic.
     *
     * @readonly
     * @private
     */
    events;
    constructor() {
        this.events = {};
    }
    emit(topic, data) {
        const topicEvents = this.events[topic] ?? [];
        topicEvents.forEach((callback) => {
            callback(data);
        });
    }
    register(topic, callback) {
        const topicEvents = this.events[topic] ?? [];
        const canAddCallback = (cb) => typeof cb === "function" && !topicEvents.includes(cb);
        if (Array.isArray(callback)) {
            topicEvents.push(...callback.filter(canAddCallback));
        }
        else if (canAddCallback(callback)) {
            topicEvents.push(callback);
        }
        this.events[topic] = topicEvents;
    }
    unregister(topic, callback) {
        if (!Array.isArray(this.events[topic]))
            return;
        this.events[topic] = this.events[topic].filter((fn) => fn !== callback);
    }
    registerSubscribers(subscribers) {
        for (const [topic, callbacks] of Object.entries(subscribers)) {
            if (Array.isArray(callbacks)) {
                callbacks.forEach((callback) => this.register(topic, callback));
            }
            else {
                this.register(topic, callbacks);
            }
        }
    }
}
const eventManager = new EventManager();

class SDKError extends Error {
    cause;
    constructor(message, cause) {
        super(message);
        this.name = "SDKError";
        this.cause = cause;
    }
}
const handleError = (err) => {
    const errMsg = err?.message ?? "[SDK] Error: something went wrong.";
    return new SDKError(errMsg, err);
};

/**
 * This class is responsible for managing interceptors, executing them and mapping them to the methods.
 */
class InterceptorsManager {
    /**
     * SDK Configuration object
     *
     * @private
     */
    config;
    /**
     * Event manager
     *
     * @private
     */
    eventManager;
    /**
     * Mapped interceptors
     *
     * @private
     */
    configuredInterceptors;
    /**
     * InterceptorsManager constructor
     *
     * @param config
     * @param eventManager
     */
    constructor(config, eventManager) {
        this.config = config;
        this.eventManager = eventManager;
        this.configuredInterceptors = this.configureInterceptors(config);
    }
    /**
     * Resolves interceptor from the configuration.
     *
     * @param {string} moduleName
     * @param {string} methodName
     * @param {InterceptorType} interceptorType
     */
    getInterceptors(moduleName, methodName, interceptorType) {
        return (this.configuredInterceptors[moduleName]?.[interceptorType]?.[methodName] ?? []);
    }
    /**
     * Resolves replacement function from the configuration object.
     *
     * @param {string} moduleName
     * @param {string} methodName
     */
    getOverride(moduleName, methodName) {
        return this.config[moduleName]?.override?.[methodName] ?? null;
    }
    /**
     * Executes configured interceptors in an ordered sequence
     *
     * @param {Interceptor} interceptors
     * @param data
     */
    // eslint-disable-next-line class-methods-use-this
    executeInterceptors = async (interceptors, data) => {
        if (!interceptors)
            return data;
        for (const interceptor of interceptors) {
            if (typeof interceptor === "function") {
                // eslint-disable-next-line no-param-reassign
                data = await interceptor(data);
            }
        }
        return data;
    };
    /**
     * Configures interceptors for a given extension
     * and returns the result
     *
     * @param config
     */
    configureInterceptors = (config) => {
        const mappedInterceptors = {};
        Object.entries(config).forEach(([extensionCode, extensionConfig]) => {
            if (extensionConfig?.interceptors) {
                mappedInterceptors[extensionCode] = this.mapInterceptors(extensionConfig.interceptors);
            }
        });
        return mappedInterceptors;
    };
    /**
     * Structure of interceptors config object is user-friendly and looks like this:
     * interceptors: [
     *     {
     *       before: {
     *         m1: [() => 'm1+a', () => 'm1+b'],
     *         m2: () => 'm2'
     *       },
     *       after: {
     *         m1: () => 'm1-after'
     *       }
     *     },
     *     {
     *       before: {
     *         m1: () => 'm1+c',
     *         m3: () => 'm3'
     *       }
     *     },
     *     ...npmPackage1,
     *     ...npmPackage2,
     *     ...
     *   ]
     *
     * It will be internally mapped to this structure:
     * interceptors: {
     *   before: {
     *     m1: [
     *       () => 'm1+a',
     *       () => 'm1+b',
     *       () => 'm1+c'
     *     ],
     *     m2: [
     *       () => 'm2'
     *     ],
     *     m3:[
     *       () => 'm3'
     *     ]
     *   },
     *   after: {
     *     m1: [
     *       () => 'm1-after'
     *     ]
     *   }
     * }
     */
    // eslint-disable-next-line class-methods-use-this
    mapInterceptors(interceptors) {
        const mappedInterceptors = {
            before: {},
            after: {},
            around: {},
        };
        interceptors.forEach((interceptor) => {
            Object.entries(interceptor).forEach(([interceptorType, interceptorMethods]) => {
                Object.entries(interceptorMethods).forEach(([methodName, methodInterceptors]) => {
                    if (!mappedInterceptors[interceptorType][methodName]) {
                        mappedInterceptors[interceptorType][methodName] = [];
                    }
                    if (Array.isArray(methodInterceptors)) {
                        mappedInterceptors[interceptorType][methodName].push(...methodInterceptors);
                    }
                    else if (typeof methodInterceptors === "function") {
                        mappedInterceptors[interceptorType][methodName].push(methodInterceptors);
                    }
                });
            });
        });
        return mappedInterceptors;
    }
    /**
     * @param {string} moduleName
     * @param {string} methodName
     * @param {any} args
     */
    async executeBeforeInterceptors(moduleName, methodName, args) {
        const interceptors = this.getInterceptors(moduleName, methodName, "before");
        return this.executeInterceptors(interceptors, args);
    }
    /**
     *
     * @param {string} moduleName
     * @param {string} methodName
     * @param {function} callback Original method
     * @param {any} args
     * @returns
     */
    async executeAroundInterceptors(moduleName, methodName, callback, args) {
        const interceptors = this.getInterceptors(moduleName, methodName, "around");
        if (!interceptors.length) {
            return callback(...args);
        }
        for (let i = interceptors.length - 1; i >= 0; i -= 1) {
            const interceptor = interceptors[i];
            const next = interceptors[i + 1] ?? callback;
            interceptors[i] = interceptor.bind(interceptor, next);
        }
        return interceptors?.[0]?.(...args) ?? callback(...args);
    }
    /**
     * @param {string} moduleName
     * @param {string} methodName
     * @param {any} result
     */
    async executeAfterInterceptors(moduleName, methodName, result) {
        const interceptors = this.getInterceptors(moduleName, methodName, "after");
        return this.executeInterceptors(interceptors, result);
    }
    /**
     * Applies interceptors to connector methods.
     *
     * @param {string} fnName Name of the interceptor subject function
     * @param {any} fn Subject of the interceptor
     * @param {string} moduleName
     * @public
     */
    applyInterceptors(fnName, fn, moduleName) {
        return async (...args) => {
            try {
                this.eventManager.emit(`*_before`, args);
                this.eventManager.emit(`${moduleName}_before`, args);
                this.eventManager.emit(`${moduleName}_${fnName}_before`, args);
                const methodArgs = await this.executeBeforeInterceptors(moduleName, fnName, args);
                const finalFn = this.getOverride(moduleName, fnName) ?? fn;
                let result = await this.executeAroundInterceptors(moduleName, fnName, finalFn, methodArgs);
                result = await this.executeAfterInterceptors(moduleName, fnName, result);
                this.eventManager.emit(`*_after`, result);
                this.eventManager.emit(`${moduleName}_after`, result);
                this.eventManager.emit(`${moduleName}_${fnName}_after`, result);
                return result;
            }
            catch (err) {
                if (err instanceof Error) {
                    throw handleError(err);
                }
                else {
                    throw err;
                }
            }
        };
    }
}

function normalizePropertyDescriptors(connector) {
    const propertyDescriptors = Object.getOwnPropertyDescriptors(connector);
    const hasNonConfigurableProperties = Object.values(propertyDescriptors).some((descriptor) => !descriptor.configurable);
    // If the connector has non-configurable properties, we need to recreate it without property descriptors
    // we don't just recrate all connectors, as they may bo proxies and so it wouldn't work.
    return hasNonConfigurableProperties ? { ...connector } : connector;
}
/**
 * Initializes SDK
 *
 * @param sdkConfig - SDK configuration
 *
 * @example
 * This is an example of how to initialize SDK
 * Providing generic type is required to get proper type inference.
 *
 * ```typescript
 * const sdkConfig = {
 *   module1: buildModule<Module1, typeof extension>(module1, {}, extension),
 *   module2: buildModule<Module2>(module2),
 * };
 *
 * const sdk = initSDK<typeof sdkConfig>(sdkConfig);
 * ```
 */
const initSDK = (sdkConfig) => {
    const interceptorsManager = new InterceptorsManager(sdkConfig, eventManager);
    const sdk = {};
    Object.keys(sdkConfig).forEach((extensionCode) => {
        const extend = sdkConfig[extensionCode]?.extend ?? {};
        const utils = sdkConfig[extensionCode]?.utils ?? {};
        const subscribers = sdkConfig[extensionCode]?.subscribers ?? {};
        eventManager.registerSubscribers(subscribers);
        /*
          Connectors are often npm packages that have been bundled, bundlers may modify contract of modules by freezing exports or modifying
          their property descriptors. The problem is that non-writeable and non-configurable properties cannot be altered by Proxy.
          See step 10 of the below algorithm
          https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver
        
          Due to this, we recreate connector but without property descriptors.
        */
        const connectorWithoutDescriptors = normalizePropertyDescriptors(sdkConfig[extensionCode].connector);
        sdk[extensionCode] = new Proxy(connectorWithoutDescriptors, {
            get(target, propKey, receiver) {
                if (propKey === "utils")
                    return utils;
                const methodFromExtend = Reflect.get(extend, propKey, receiver);
                const methodFromTarget = Reflect.get(target, propKey, receiver);
                const method = methodFromExtend ?? methodFromTarget;
                if (!method)
                    return method;
                const wrappedMethod = interceptorsManager.applyInterceptors(propKey, method, extensionCode);
                return wrappedMethod;
            },
        });
    });
    return sdk;
};

/* eslint-disable no-param-reassign */
/**
 * Performs a deep merge of objects and returns new object. Does not modify
 * objects (immutable) and merges arrays via concatenation.
 *
 * @param {...object} objects - Objects to merge
 * @returns {object} New object with merged key/values
 */
function mergeDeep(...objects) {
    const isObject = (obj) => obj && typeof obj === "object";
    return objects.reduce((prev, obj) => {
        Object.keys(obj ?? {}).forEach((key) => {
            const pVal = prev[key];
            const oVal = obj[key];
            if (Array.isArray(pVal) && Array.isArray(oVal)) {
                prev[key] = pVal.concat(...oVal);
            }
            else if (isObject(pVal) && isObject(oVal)) {
                prev[key] = mergeDeep(pVal, oVal);
            }
            else {
                prev[key] = oVal;
            }
        });
        return prev;
    }, {});
}

/* eslint-disable no-redeclare */
// === Implementation ===
/**
 * Build module with extension.
 * Provide a module factory function and an extension object.
 *
 */
function buildModule(module, moduleOptions, extension, extensionOptions) {
    const resolvedModule = module(moduleOptions);
    const resolvedExtension = typeof extension === "function"
        ? extension(extensionOptions, {
            methods: resolvedModule.connector,
            context: resolvedModule?.context ?? {},
        })
        : extension ?? {};
    return mergeDeep(resolvedModule, resolvedExtension);
}

/**
 * Symbol to mark a method config object.
 */
const isConfig = Symbol("config");

/**
 * SDK connector.
 * It's used to create the methods for the SDK.
 * Implements the Proxy pattern.
 */
const connector = (requestSender) => {
    const target = {};
    return new Proxy(target, {
        get: (_, methodName) => {
            if (typeof methodName !== "string") {
                throw new Error("Method must be a string");
            }
            return async (...params) => {
                let config;
                const lastParam = params.at(-1);
                // If last parameter contains the `isRequestConfig` symbol, it's a request config
                if (typeof lastParam === "object" && lastParam?.[isConfig]) {
                    // Remove the `isRequestConfig` symbol from the request config
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { [isConfig]: omit, ...rest } = params.pop();
                    config = rest;
                }
                return requestSender(methodName, params, config);
            };
        },
    });
};

/**
 * Represents a custom error for SDK HTTP operations.
 */
class SdkHttpError extends Error {
    /** The HTTP status code associated with this error. */
    statusCode;
    /**
     * Constructs an instance of `SDKError`.
     */
    constructor(errorParams) {
        const { message, statusCode, cause = undefined } = errorParams;
        super(message, { cause });
        this.statusCode = statusCode;
    }
}
/**
 * Checks if the given error was caused by `SDKError`.
 * @param error - The error to check.
 * @returns A type predicate indicating whether the error is an `ErrorCausedBySDKError`.
 * @example
 * ```typescript
 * catch (error) {
 *   if (isCausedBySdkError(error)) {
 *     const statusCode = error.cause.statusCode;
 *   }
 * }
 * ```
 */
const isCausedBySdkHttpError = (error) => error instanceof Error &&
    "cause" in error &&
    error.cause instanceof SdkHttpError;
/**
 * Checks if the given error was caused by `SDKError` and matches a specific status code or condition.
 * @param error - The error to check.
 * @param statusCodePredicate - The predicate to match the error's status code against.
 * @returns A type predicate indicating whether the error matches the specific condition.
 * @example
 * ```typescript
 * catch (error) {
 *   if (isSpecificSdkError(error, { statusCode: 422 })) {
 *     // handle 422
 *   }
 * }
 * ```
 * @example
 * ```typescript
 * catch (error) {
 *   if (isSpecificSdkError(error, { statusCode: (code) => code === 401 || code === 403 })) {
 *     // handle 401 or 403
 *   }
 * }
 * ```
 */
const isSpecificSdkHttpError = (error, statusCodePredicate) => isCausedBySdkHttpError(error) &&
    (typeof statusCodePredicate.statusCode === "function"
        ? statusCodePredicate.statusCode(error.cause.statusCode)
        : error.cause.statusCode === statusCodePredicate.statusCode);
/**
 * Checks if the given error was caused by `SDKError` and its status code is between 400 and 500, indicating a client error.
 * @param error - The error to check.
 * @returns A type predicate indicating whether the error is a client error caused by `SDKError`.
 * @example
 * ```typescript
 * catch (error) {
 *   if (isSdkRequestError(error)) {
 *     // handle client error
 *   }
 * }
 * ```
 */
const isSdkRequestError = (error) => isSpecificSdkHttpError(error, {
    statusCode: (code) => code >= 400 && code < 500,
});
/**
 * Checks if the given error was caused by `SDKError` and its status code is 401, indicating an unauthorized request error.
 * @param error - The error to check.
 * @returns A type predicate indicating whether the error is an unauthorized request error caused by `SDKError`.
 * @example
 * ```typescript
 * catch (error) {
 *   if (isSdkUnauthorizedError(error)) {
 *     // handle unauthorized error
 *   }
 * }
 * ```
 */
const isSdkUnauthorizedError = (error) => isSpecificSdkHttpError(error, { statusCode: 401 });

/**
 * Generates a `RequestSender` function configured according to the provided options.
 *
 * @remarks
 * This function abstracts away the details of constructing request URLs, merging configurations,
 * handling errors, and executing HTTP requests.
 */
const getRequestSender = (options) => {
    const { apiUrl, ssrApiUrl, defaultRequestConfig = {}, methodsRequestConfig = {}, } = options;
    const getUrl = (path, method, params) => {
        // Determine the base URL based on the environment
        const baseUrl = typeof window === "undefined" ? ssrApiUrl || apiUrl : apiUrl;
        // Ensure the base URL ends with a slash.
        // TODO: Update eslint rule to warn on prefer-template instead of error.
        // eslint-disable-next-line prefer-template
        const normalizedBaseUrl = baseUrl.replace(/\/+$/, "") + "/";
        const url = `${normalizedBaseUrl}${path}`;
        // If there are no query params, return the URL as is
        if (method !== "GET") {
            return url;
        }
        // If there are query params, append them to the URL as `?body=[<strignified query params>]`
        const serializedParams = encodeURIComponent(JSON.stringify(params));
        return `${url}?body=${serializedParams}`;
    };
    const getConfig = (config, methodConfig) => {
        const { method, headers } = config;
        const { headers: methodHeaders = {} } = methodConfig;
        const defaultHeaders = {
            "Content-Type": "application/json",
            Accept: "application/json",
            ...defaultRequestConfig.headers,
        };
        const mergedHeaders = {
            ...defaultHeaders,
            ...methodHeaders,
            ...headers,
        };
        const computedHeaders = {};
        Object.entries(mergedHeaders).forEach(([key, value]) => {
            computedHeaders[key] = Array.isArray(value) ? value.join(",") : value;
        });
        return {
            ...config,
            method,
            headers: {
                ...computedHeaders,
            },
        };
    };
    const defaultHTTPClient = async (url, params, config) => {
        const response = await fetch(url, {
            ...config,
            body: JSON.stringify(params),
            credentials: "include",
        });
        const responseJson = await response.json().catch(() => undefined);
        if (!response.ok) {
            throw new SdkHttpError({
                statusCode: response.status,
                message: responseJson?.message,
            });
        }
        return responseJson;
    };
    const defaultErrorHandler = async ({ error }) => {
        throw error;
    };
    return async (methodName, params, config) => {
        const { httpClient = defaultHTTPClient, errorHandler = defaultErrorHandler, } = options;
        const { method, headers = {}, ...restConfig } = config ?? {};
        const methodConfig = methodsRequestConfig[methodName] || {};
        const finalMethod = method || methodConfig.method || defaultRequestConfig.method || "POST";
        const computedParams = finalMethod === "GET" ? [] : params;
        const finalUrl = getUrl(methodName, finalMethod, params);
        const finalConfig = getConfig({ method: finalMethod, headers, ...restConfig }, methodConfig);
        try {
            return await httpClient(finalUrl, computedParams, finalConfig);
        }
        catch (error) {
            return await errorHandler({
                error,
                methodName,
                url: finalUrl,
                params: computedParams,
                config: finalConfig,
                httpClient,
            });
        }
    };
};

/**
 * Prepare the config for the request.
 * It's used to differentiate the method config from the params.
 *
 * @example
 * Usage
 * ```ts
 * import { prepareConfig } from "@vue-storefront/sdk";
 *
 * const products = sdk.commerce.getProducts(params, prepareConfig({ method: "GET" }));
 * ```
 */
const prepareConfig = (requestConfig) => {
    return {
        ...requestConfig,
        [isConfig]: true,
    };
};

/**
 * `middlewareModule` is allowing to communicate with the Server Middleware API.
 *
 * It generates the methods to communicate with the API based on the provided endpoints interface.
 *
 * @example
 * Setup:
 * ```ts
 * import { createSdk } from "@vue-storefront/next";
 * import type { SapccEndpoints } from "../storefront-middleware/types";
 *
 * export const { getSdk } = createSdk(options, ({ buildModule, middlewareModule }) => ({
 *   sapcc: buildModule(middlewareModule<SapccEndpoints>, {
 *     apiUrl: "http://localhost:4000/sapcc",
 *   }),
 * }));
 * ```
 *
 * It also exposes the `context` with the `requestSender` to allow to use it directly in extensions.
 *
 * @example
 * Usage:
 * ```ts
 * import { createSdk } from "@vue-storefront/next";
 * import type { SapccEndpoints } from "../storefront-middleware/types";
 *
 * const extension = (extensionOptions, { methods, context }) => ({
 *   extend: {
 *     async newMethod(params) {
 *       const response = await context.requestSender("customMethod", [params]);
 *       const products = await methods.getProducts(params);
 *       return { ...response, ...products };
 *     }
 *   }
 * });
 *
 * export const { getSdk } = createSdk(options, ({ buildModule, middlewareModule }) => ({
 *   sapcc: buildModule(middlewareModule<SapccEndpoints>, {
 *     apiUrl: "http://localhost:4000/sapcc",
 *   }, extension),
 * }));
 * ```
 */
const middlewareModule = (options) => {
    const requestSender = getRequestSender(options);
    return {
        connector: connector(requestSender),
        context: {
            requestSender,
        },
    };
};

/**
 * An old alias for initSDK function.
 *
 * @deprecated
 */
const initVSFSDK = initSDK;

exports.SdkHttpError = SdkHttpError;
exports.buildModule = buildModule;
exports.eventManager = eventManager;
exports.getRequestSender = getRequestSender;
exports.handleError = handleError;
exports.initSDK = initSDK;
exports.initVSFSDK = initVSFSDK;
exports.isCausedBySdkHttpError = isCausedBySdkHttpError;
exports.isSdkRequestError = isSdkRequestError;
exports.isSdkUnauthorizedError = isSdkUnauthorizedError;
exports.isSpecificSdkHttpError = isSpecificSdkHttpError;
exports.middlewareModule = middlewareModule;
exports.prepareConfig = prepareConfig;
//# sourceMappingURL=index.cjs.js.map
