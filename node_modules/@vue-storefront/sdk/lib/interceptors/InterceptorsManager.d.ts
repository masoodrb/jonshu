import type { EventManagerInterface } from "../events/EventManager";
import type { InterceptorType, SDKConfig } from "../types";
import { AnyFunction } from "../types";
/**
 * This class is responsible for managing interceptors, executing them and mapping them to the methods.
 */
export declare class InterceptorsManager<Config extends SDKConfig> {
    /**
     * SDK Configuration object
     *
     * @private
     */
    private readonly config;
    /**
     * Event manager
     *
     * @private
     */
    private readonly eventManager;
    /**
     * Mapped interceptors
     *
     * @private
     */
    private readonly configuredInterceptors;
    /**
     * InterceptorsManager constructor
     *
     * @param config
     * @param eventManager
     */
    constructor(config: Config, eventManager: EventManagerInterface);
    /**
     * Resolves interceptor from the configuration.
     *
     * @param {string} moduleName
     * @param {string} methodName
     * @param {InterceptorType} interceptorType
     */
    getInterceptors(moduleName: string, methodName: string, interceptorType: InterceptorType): AnyFunction[];
    /**
     * Resolves replacement function from the configuration object.
     *
     * @param {string} moduleName
     * @param {string} methodName
     */
    getOverride(moduleName: string, methodName: string): AnyFunction | null;
    /**
     * Executes configured interceptors in an ordered sequence
     *
     * @param {Interceptor} interceptors
     * @param data
     */
    private executeInterceptors;
    /**
     * Configures interceptors for a given extension
     * and returns the result
     *
     * @param config
     */
    private configureInterceptors;
    /**
     * Structure of interceptors config object is user-friendly and looks like this:
     * interceptors: [
     *     {
     *       before: {
     *         m1: [() => 'm1+a', () => 'm1+b'],
     *         m2: () => 'm2'
     *       },
     *       after: {
     *         m1: () => 'm1-after'
     *       }
     *     },
     *     {
     *       before: {
     *         m1: () => 'm1+c',
     *         m3: () => 'm3'
     *       }
     *     },
     *     ...npmPackage1,
     *     ...npmPackage2,
     *     ...
     *   ]
     *
     * It will be internally mapped to this structure:
     * interceptors: {
     *   before: {
     *     m1: [
     *       () => 'm1+a',
     *       () => 'm1+b',
     *       () => 'm1+c'
     *     ],
     *     m2: [
     *       () => 'm2'
     *     ],
     *     m3:[
     *       () => 'm3'
     *     ]
     *   },
     *   after: {
     *     m1: [
     *       () => 'm1-after'
     *     ]
     *   }
     * }
     */
    private mapInterceptors;
    /**
     * @param {string} moduleName
     * @param {string} methodName
     * @param {any} args
     */
    private executeBeforeInterceptors;
    /**
     *
     * @param {string} moduleName
     * @param {string} methodName
     * @param {function} callback Original method
     * @param {any} args
     * @returns
     */
    private executeAroundInterceptors;
    /**
     * @param {string} moduleName
     * @param {string} methodName
     * @param {any} result
     */
    private executeAfterInterceptors;
    /**
     * Applies interceptors to connector methods.
     *
     * @param {string} fnName Name of the interceptor subject function
     * @param {any} fn Subject of the interceptor
     * @param {string} moduleName
     * @public
     */
    applyInterceptors(fnName: string, fn: AnyFunction, moduleName: string): ReturnType<typeof fn>;
}
//# sourceMappingURL=InterceptorsManager.d.ts.map