import { ref as n, watch as S, computed as P } from "vue";
import { unrefElement as D, noop as w } from "@vueuse/core";
import { Scrollable as I } from "@storefront-ui/shared";
function y(e) {
  const t = n(), v = n(null), a = n({ hasPrev: !1, hasNext: !1, isDragged: !1 });
  let d = w;
  S(
    [t, e],
    () => {
      var h, m, s;
      const l = D(t);
      if (!l)
        return;
      d(), v.value = new I(l, {
        ...e == null ? void 0 : e.value,
        onScroll: (u) => {
          var r, c;
          a.value = { ...a.value, hasNext: u.hasNext, hasPrev: u.hasPrev }, (c = (r = e == null ? void 0 : e.value) == null ? void 0 : r.onScroll) == null || c.call(r, u);
        },
        onDragStart: (u) => {
          var r, c;
          a.value = { ...a.value, isDragged: u.isDragged }, (c = (r = e == null ? void 0 : e.value) == null ? void 0 : r.onDragStart) == null || c.call(r, u);
        }
      }), d = (h = v.value) == null ? void 0 : h.register();
      const f = (m = e == null ? void 0 : e.value) == null ? void 0 : m.activeIndex;
      typeof f == "number" && f >= 0 && ((s = e == null ? void 0 : e.value) != null && s.isActiveIndexCentered) && v.value.scrollToIndex(f);
    },
    { immediate: !0, deep: !0 }
  );
  const g = () => {
    var l;
    (l = v.value) == null || l.prev();
  }, x = () => {
    var l;
    (l = v.value) == null || l.next();
  }, b = P(() => ({
    onClick: g,
    disabled: !a.value.hasPrev
  })), N = P(() => ({
    onClick: x,
    disabled: !a.value.hasNext
  }));
  return {
    containerRef: t,
    getPrevButtonProps: b,
    getNextButtonProps: N,
    showNext: x,
    showPrev: g,
    state: a
  };
}
export {
  y as useScrollable
};
