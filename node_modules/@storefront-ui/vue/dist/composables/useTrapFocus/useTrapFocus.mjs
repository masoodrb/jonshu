import { unrefElement as N } from "@vueuse/core";
import { tabbable as F } from "tabbable";
import { ref as n, watch as R } from "vue";
import { focusNext as A, focusPrev as h, isTab as U, isTabAndShift as C } from "@storefront-ui/shared";
import { waitForNextRender as G } from "../../shared/render.mjs";
var O = /* @__PURE__ */ ((t) => (t.autofocus = "autofocus", t.container = "container", t))(O || {});
const P = {
  trapTabs: !0,
  activeState: n(!0),
  initialFocus: 0,
  initialFocusContainerFallback: !1,
  arrowKeysOn: !1,
  arrowKeysLeftRight: !1,
  arrowKeysUpDown: !1
}, E = (t, K) => {
  const {
    trapTabs: w,
    arrowFocusGroupSelector: l,
    includeContainer: d,
    activeState: D,
    initialFocus: u,
    // eslint-disable-next-line etc/no-deprecated
    arrowKeysOn: y,
    arrowKeysLeftRight: p,
    arrowKeysUpDown: b,
    initialFocusContainerFallback: g
  } = {
    ...P,
    ...K
  }, i = n(), s = n([]);
  let e;
  const v = () => {
    i.value = document.activeElement;
  }, f = ({
    event: o,
    additionalData: a
  }) => h({
    current: i.value,
    focusables: s.value,
    event: o,
    ...a
  }), c = ({
    event: o,
    additionalData: a
  }) => A({
    current: i.value,
    focusables: s.value,
    event: o,
    ...a
  }), m = (o) => {
    const r = l && (e == null ? void 0 : e.querySelector(l)) ? { arrowFocusGroupSelector: l } : {};
    y && (o.key === "ArrowLeft" || o.key === "ArrowUp") && f({ additionalData: r }), y && (o.key === "ArrowRight" || o.key === "ArrowDown") && c({ additionalData: r }), p && o.key === "ArrowLeft" && f({ additionalData: r }), p && o.key === "ArrowRight" && c({ additionalData: r }), b && o.key === "ArrowUp" && f({ additionalData: r }), b && o.key === "ArrowDown" && c({ additionalData: r }), w && U(o) && c({ event: o }), w && C(o) && f({ event: o });
  }, x = () => {
    e == null || e.removeEventListener("keydown", m), e == null || e.removeEventListener("focus", v, !0);
  };
  return R(
    [t, D],
    async ([o, a]) => {
      if (o && a) {
        let r = !1;
        if (await G(), e = N(o), e == null || e.addEventListener("focus", v, !0), e == null || e.addEventListener("keydown", m), s.value = F(e, { includeContainer: d }), typeof u == "number")
          s.value[u] ? s.value[u].focus() : (console.error(`There is no element with given index ${u}`), r = !0);
        else if (u === "autofocus") {
          const k = s.value.find((S) => S.hasAttribute("autofocus"));
          k ? k.focus() : r = !0;
        }
        (g && r || u === "container") && (e == null || e.focus());
      } else
        s.value = [], i.value = void 0, x();
    },
    { immediate: !0 }
  ), {
    current: i,
    focusables: s,
    focusNext: A,
    focusPrev: h,
    updateFocusableElements: () => {
      s.value = F(t.value, { includeContainer: d });
    }
  };
};
export {
  O as InitialFocusType,
  E as useTrapFocus
};
